in ns_access.c, there is a LIMIT to the hash table size related to the access Control
data structure. "INITIAL_TABLE_SIZE". also, we only allow 50% of INITIAL_TABLE_SIZE as the actual
number of users in the system -> "LOWER LOAD FACTOR" 

Lower Load Factor (e.g., 50%)
‚úÖ Fewer collisions - Less likely that multiple keys hash to the same bucket
‚úÖ Faster lookups - O(1) average case stays closer to O(1)
‚úÖ Shorter chains - When collisions occur, the linked lists are shorter
‚ùå More memory - Wastes 50% of allocated space

Higher Load Factor (e.g., 90%)
‚úÖ Better memory utilization - Uses most of the allocated space
‚ùå More collisions - Many keys hash to same bucket
‚ùå Slower lookups - O(1) degrades toward O(n) as chains grow
‚ùå Longer chains - More nodes to traverse in linked lists

---------------------------------------------------------
Issues found:

- "READ"ing a file does not update its "Last Access" time in both VIEW -l & INFO
- "Size" not updating in "VIEW -l" & INFO
- have to add sentence count & character count in "VIEW -l" & "INFO"

------------------------------------------------------
ANALYZING CONNECTION 

Is accept() thread-safe?

‚úÖ Yes! From POSIX spec:

"If multiple threads call accept() on the same listening socket, each will block until a new connection arrives, and exactly one thread will accept it."

So you CAN have multiple threads calling accept() on the same listener:


========
Part 1: Different Sockets, Same Port
Yes! All connections share port 8080, but have different socket fds.
========
Part 2: Thread Safety Handled by Socket API?
Partially:

Operation	Kernel Handles Thread Safety?
accept() on listener	‚úÖ Yes - Fully thread-safe
send(fd4) vs send(fd5)	‚úÖ Yes - Different sockets, no conflict
send(fd4) from multiple threads	‚ö†Ô∏è Partially - Each call is atomic, but can interleave
Your send_response(fd4)	‚ùå No - Two send() calls not atomic together
===============
THREAD SAFETY IN SOCKET OPERATIONS

Port vs Socket FD:
- Port 8080 (listening): One "doorway" shared by all connections
- Socket fds (4, 5, 6...): Individual "rooms" for each connection
- All connections use same port, but different socket fds

What Kernel Handles (Thread-Safe):
‚úÖ accept() - Serialized with internal lock, one thread per connection
‚úÖ Port demultiplexing - Routes packets to correct socket based on 4-tuple
‚úÖ Per-socket buffers - Each fd has separate send/recv buffer
‚úÖ Single send() call - Bytes within one call stay together

What Application Must Handle (Not Thread-Safe):
‚ùå Multiple send() calls as atomic unit - Need mutex for header+payload
‚ùå Shared socket from multiple threads - Need mutex in send_response()
‚ùå Protocol message boundaries - Kernel doesn't know your protocol

Solution: Add mutex to send_response() to make header+payload atomic

---------------------------------------------------------
üî¥ CRITICAL NETWORKING ISSUES IN net_utils.c

Issue 1: Partial Send/Recv Not Handled (SEVERE)
------------------------------------------------
Problem:
- send() and recv() can return LESS bytes than requested (not an error!)
- Current code treats partial writes/reads as failures
- Example: send(sock, data, 1000) might return 500 (success, but partial)

Current Code:
```c
if (send(sock, &header, sizeof(MsgHeader), 0) != sizeof(MsgHeader)) {
    return -1;  // ‚ùå Wrong! Might be partial write
}
```

Impact: Data loss, connection corruption

Fix: Implement send_all() that loops until all bytes sent:
```c
static int send_all(int sock, const void* buffer, size_t len) {
    size_t bytes_sent = 0;
    while (bytes_sent < len) {
        ssize_t res = send(sock, buf + bytes_sent, len - bytes_sent, MSG_NOSIGNAL);
        if (res < 0) {
            if (errno == EINTR) continue;  // Signal interrupted, retry
            return -1;
        }
        bytes_sent += res;
    }
    return 1;
}
```

Issue 2: No Thread Safety (CRITICAL)
-------------------------------------
Problem:
- Multiple threads can call send_response() on same socket
- Header and payload sent in TWO separate send() calls
- Another thread can interleave between them

Example Race Condition:
```
Thread 1: send(sock, header_A, 8)
Thread 2: send(sock, header_B, 8)    ‚Üê INTERLEAVED!
Thread 1: send(sock, payload_A, 100)
Thread 2: send(sock, payload_B, 200)

Wire: [header_A][header_B][payload_A][payload_B]
      Receiver reads header_A, then header_B as payload ‚Üí CORRUPTED!
```

When This Happens:
- Storage Server: Heartbeat thread + file operation handler both use ns_sock
- Name Server: Multiple client handlers might report to same SS

Impact: Protocol corruption, connection unusable

Fix: Add per-socket mutex:
```c
#include <pthread.h>
#define MAX_SOCKETS 1024
static pthread_mutex_t socket_mutexes[MAX_SOCKETS];

int send_response(int sock, ...) {
    pthread_mutex_lock(&socket_mutexes[sock]);
    // Send header + payload atomically
    pthread_mutex_unlock(&socket_mutexes[sock]);
}
```

Issue 3: SIGPIPE Kills Process (CRITICAL)
------------------------------------------
Problem:
- When peer closes connection, send() triggers SIGPIPE signal
- Default action: Terminates entire server/client process

Impact: Server crash on client disconnect

Fix: In main():
```c
#include <signal.h>
signal(SIGPIPE, SIG_IGN);  // Ignore, get EPIPE error instead
```

Or use MSG_NOSIGNAL flag:
```c
send(sock, buf, len, MSG_NOSIGNAL);
```

Issue 4: No Timeout Protection (HIGH)
--------------------------------------
Problem:
- recv() blocks forever if peer hangs/crashes without closing
- send() blocks forever if network congested

Impact: Threads freeze indefinitely, server appears hung

Fix: Set socket timeouts:
```c
struct timeval tv;
tv.tv_sec = 30;  // 30 second timeout
tv.tv_usec = 0;
setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
```

Issue 5: No Size Validation (SECURITY)
---------------------------------------
Problem:
- Malicious client can send payload_len = 4GB
- recv() tries to read 4GB into small buffer ‚Üí buffer overflow

Impact: Memory corruption, segfault, security vulnerability

Fix: Validate in recv_header():
```c
int recv_header(int sock, MsgHeader* header) {
    int res = recv_all(sock, header, sizeof(MsgHeader));
    if (res == 1 && header->payload_len > MAX_PAYLOAD) {
        fprintf(stderr, "Payload too large: %u\n", header->payload_len);
        return -1;
    }
    return res;
}
```

Issue 6: No Endianness Handling (PORTABILITY)
----------------------------------------------
Problem:
- Sending uint32_t directly across network
- x86 (little-endian) ‚Üî ARM (big-endian) ‚Üí data corruption
- Example: 256 (0x00000100) becomes 16777216 (0x00010000)

Impact: Broken protocol on mixed architectures

Fix: Use network byte order conversion:
```c
#include <arpa/inet.h>

// Sender:
header.type = htonl((uint32_t)type);           // Host to Network
header.payload_len = htonl(len);

// Receiver:
header.type = (MsgType)ntohl(header.type);     // Network to Host
header.payload_len = ntohl(header.payload_len);
```

---------------------------------------------------------
PRIORITY OF FIXES

üî¥ Must Fix Immediately:
1. Partial send/recv handling (data loss)
2. Thread safety mutex (corruption)
3. SIGPIPE handling (server crashes)

üü° Should Fix Soon:
4. Timeout protection (hangs)
5. Size validation (security)
6. Endianness conversion (portability)

---------------------------------------------------------
TCP BEHAVIOR NOTES

send() Blocking Behavior:
- Blocks when TCP send buffer is FULL
- Does NOT block waiting for ACK from receiver
- Does NOT block waiting for receiver to read data
- Returns number of bytes copied to kernel buffer
- Can return partial write (< requested) even when blocking

recv() Return Values:
- > 0: Success, this many bytes received
- 0: Connection closed by peer (FIN packet received)
- -1: Error (check errno)
  - EINTR: Signal interrupted, retry
  - EAGAIN/EWOULDBLOCK: Timeout (if SO_RCVTIMEO set)

What TCP Handles Automatically:
‚úÖ Packet retransmission (RTO with exponential backoff)
‚úÖ ACK handling (cumulative acknowledgments)
‚úÖ Flow control (window size management)
‚úÖ Congestion control (slow start, congestion avoidance)
‚úÖ In-order delivery (reorders packets)
‚úÖ Connection state tracking (SYN, FIN, RST)

What Application Must Handle:
‚ùå Partial writes/reads (loop until complete)
‚ùå Message boundaries (TCP is byte stream, not messages)
‚ùå Application-level ACKs (TCP ACK != "processed successfully")
‚ùå Timeouts (TCP can take 2+ minutes to detect dead connection)
‚ùå Thread synchronization (multiple threads on same socket)
------------------------------------------------------------
Location	Flaw	Severity	Fix
SS heartbeat	Raw send(), no mutex	üî¥ Critical	Use send_response()
SS file list	Assumes single send() works	üî¥ Critical	Loop with send_response()
SS g_ns_sock	Race between heartbeat + handlers	üî¥ Critical	Mutex in send_response()
All components	No SIGPIPE handler	üî¥ Critical	Add signal(SIGPIPE, SIG_IGN)
Client	Duplicate send implementation	üü° Medium	Use common net_utils.c
SS replicator	Raw recv(), partial reads	üî¥ Critical	Use recv_all()
All components	No timeouts	üü° Medium	Set SO_RCVTIMEO/SO_SNDTIMEO
All send/recv	No endianness conversion	üü° Medium	Use htonl()/ntohl()
üéØ Priority Action Items
Immediate (Must Fix Before Testing):
‚úÖ Add signal(SIGPIPE, SIG_IGN) to all three main.c files
‚úÖ Change heartbeat to use send_response() instead of raw send()
‚úÖ Fix file list send to loop with send_response()
‚úÖ Update net_utils.c with mutex (already provided earlier)
‚úÖ Fix replicator to use recv_all()
Important (Should Fix Soon):
Add timeout support to all sockets
Add endianness conversion
Consolidate client's duplicate networking code
The heartbeat mechanism is well-designed, but the networking implementation has critical thread-safety issues that will cause random failures under load!
==========================================================================
...existing content...

---------------------------------------------------------
üî¥ HEARTBEAT GAP PROBLEM

Issue: Dead SS Before Timeout Detection
----------------------------------------
Timeline:
Time 0:00 - SS1 crashes
Time 0:05 - Client requests file
Time 0:06 - NS returns SS1 (still marked ONLINE)
Time 0:07 - Client can't connect ‚Üí USER SEES ERROR
Time 0:15 - Heartbeat timeout, NS marks SS1 offline (too late!)

Problem Window: 0-15 seconds where clients get routed to dead SS

Root Cause in Code:
1. ns_ss_manager.c:find_ss_for_file() - Only checks if SS has file, not if alive
2. No check: time(NULL) - ss->last_heartbeat > threshold
3. Client doesn't report connection failures back to NS

Fixes Required:
‚úÖ Check SS status AND heartbeat timestamp in find_ss_for_file()
‚úÖ Client should report connection failures to NS (new message type)
‚úÖ Client should retry with exponential backoff
‚úÖ NS should immediately mark SS offline on client failure report

---------------------------------------------------------
üî¥ FILE LIST SEND FLAW (ss_main.c:60)

Problem: Sends Entire File List in One send() Call
---------------------------------------------------
Code:
```c
FileMetadata* file_list = malloc(1000 * sizeof(FileMetadata));
int file_count = scan_files_on_disk(file_list, 1000);

// üî¥ BROKEN: Assumes send() sends all bytes
if (send(g_ns_sock, file_list, file_count * sizeof(FileMetadata), 0) 
    != file_count * sizeof(FileMetadata)) {
    exit(1);  // SS exits if partial write!
}
```

What This Does:
- During SS startup, scans disk for existing files
- Sends list to NS so NS knows "SS1 has files X, Y, Z"
- NS registers these files in its metadata

Why It's Broken:
1. sizeof(FileMetadata) ‚âà 1KB per file
2. 1000 files = 1 MB of data
3. TCP buffer typically 64KB
4. send() returns 65536 (success, but only sent 64KB!)
5. Code treats as failure ‚Üí SS exits ‚Üí never starts!

Fix: Send One File at a Time
```c
for (int i = 0; i < file_count; i++) {
    if (send_response(g_ns_sock, MSG_S2N_FILE_METADATA, 
                      &file_list[i], sizeof(FileMetadata)) < 0) {
        ss_log("Failed to send file metadata");
        exit(1);
    }
}
send_response(g_ns_sock, MSG_S2N_FILE_LIST_END, NULL, 0);
```

NS Must Update to Loop:
```c
while (recv_header(ss_sock, &header) > 0) {
    if (header.type == MSG_S2N_FILE_LIST_END) break;
    
    FileMetadata meta;
    recv_payload(ss_sock, &meta, header.payload_len);
    register_file_from_ss(ss_id, &meta);
}
```
====================================================================================================
